<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Karplus-Strong stress tester</title>
    <script>
        // Import @padenot's ringbuf.js library for passing
        // data between AudioWorklet and the main thread
        // using SharedArrayBuffers in a lock-free way.
        exports = {};
    </script>
    <script src="ringbuf/index.js"></script>
    <script src="webmidi/webmidi.min.js"></script>
</head>

<body style="padding: 0px; margin: 0px; font-family: sans-serif">
    <div style="position: fixed; top: 0; left: 0; background-color: #eee; padding: 5px">
        <a href="https://github.com/jackschaedler/karplus-stress-tester">Learn more</a>
    </div>
    <div style="display: flex; flex-direction: row; width: 100%">
        <div style="flex-basis: 70%;">
            <div style="width: 75%; margin-left: auto; margin-right: auto; margin-top: 2em; position: relative">
                <div id="vis" style="position: absolute; top: 0; left: 0; right: 0"></div>
                <div id="vis-hitareas" style="position: absolute; top: 0; left: 0; right: 0"></div>
            </div>
        </div>
        <div style="flex-basis: 30%; background-color: #eee; padding: 15px;">
            <div>
                <button id="start-button" onclick="runExample()" style="width: 100%; height: 100px; font-size: 1.5em;">Start audio üîä</button>
                <button id="pluck-button" onclick="pluck()" style="height: 50px; width:100%; display: none; font-size: 1.5em;">pluck</button>
                <button id="swipe-button" onclick="swipe()" style="height: 50px; width:100%; display: none; font-size: 1.5em;">swipe</button>
                <button id="strum-button" onclick="strum()" style="height: 50px; width:100%; display: none; font-size: 1.5em;">strum all</button>
            </div>
            <div>
                <h2>Parameters</h2>
                <h4 style="margin-bottom: 5px">Number of strings</h4>
                <button id="10-button" onclick="changeStrings(10)">10</button>
                <button id="25-button" onclick="changeStrings(25)">25</button>
                <button id="50-button" onclick="changeStrings(50)">50</button>
                <button id="100-button" onclick="changeStrings(100)">100</button>
                <button id="200-button" onclick="changeStrings(200)">200</button>
                <button id="250-button" onclick="changeStrings(250)">250</button>
                <button id="400-button" onclick="changeStrings(400)">400</button>
                <button id="600-button" onclick="changeStrings(600)">600</button>
                <button id="1000-button" onclick="changeStrings(1000)">1000</button>
                <p style="font-size: 0.7em; color: #999">Beware! Large numbers of strings might light your device on fire.
                Even when the the strings aren't audible, they are all simulating.</p>
                <section>
                    <h4 style="margin-bottom: 5px">Strings per AudioWorklet</h4>
                    <p style="font-size: 0.7em; color: #999">This allows you to get a feel for the overhead
                    introduced by each AudioWorklet node. Having fewer nodes leads to fewer glitches.</a></p>
                    <div>
                        <input type="radio" id="choice-1" name="ratio" value="1" onchange="changeRatio(1)" />
                        <label style="font-size: 0.8em;" for="choice-1">1 string per worklet</label>
                    </div>
                    <div>
                        <input type="radio" id="choice-100" name="ratio" value="100" onchange="changeRatio(100)" />
                        <label style="font-size: 0.8em;" for="choice-100">100 strings per worklet (faster)</label>
                    </div>
                </section>
                <section>
                    <h4 style="margin-bottom: 5px">Communication channel</h4>
                    <p style="font-size: 0.7em; color: #999">There are two options for sending data between the audio rendering thread and the GUI (main) thread: 
                    MessagePort (which creates garbage) or using SharedArrayBuffers (which do not necessarily create garbage). When SharedArrayBuffer is selected, this page is 
                    using <a href="https://github.com/padenot/ringbuf.js">Paul Adenot's lock-free queue library.</a></p>
                    <div>
                        <input type="radio" id="choice-port" name="channel" value="port" onchange="changeChannel('port')" />
                        <label style="font-size: 0.8em;" for="choice-port">MessagePort</label>
                    </div>
                    <div>
                        <input type="radio" id="choice-sab" name="channel" value="sab" onchange="changeChannel('sab')" />
                        <label style="font-size: 0.8em;" for="choice-sab">SharedArrayBuffer (better)</label>
                    </div>
                </section>
                <p style="font-size: 0.7em; color: #999">‚ö†Ô∏è You need to be using an up-to-date version of Chrome, or
                    Firefox Nightly with the "bypassCOOP_COEP.insecure.enabled"
                    flag flipped on to use SharedArrayBuffers.
                </p>
                <section>
                    <h4 style="margin-bottom: 5px">Visualize string state <input id="vis-checkbox" type="checkbox" onchange="toggleStringVisualization()"/></h4>
                    <p style="font-size: 0.7em; color: #999">Check this box to make the strings animate whenever they
                    are plucked. The animation is based on data which is produced in the audio-processing
                    simulation(s). Therefore, turning this off will improve performance, and allow you to 
                    potentially simulate more strings.</p>
                </section>
                <section id="webmidi-control">
                    <h4>WebMidi</h4>
                    <p style="font-size: 0.7em; color: #999">This browser does not support WebMidi</p>
                </section>
            </div>
        </div>
    </div>

    <script>
        // This URLFromFiles function is used to concatenate
        // files together at runtime. This removes the need to
        // do some sort of bundling/packaging at build time.
        function URLFromFiles(files) {
            const promises = files
                .map((file) => fetch(file)
                    .then((response) => response.text()));

            return Promise
                .all(promises)
                .then((texts) => {
                    const text = texts.join('');
                    const blob = new Blob([text], { type: "application/javascript" });

                    return URL.createObjectURL(blob);
                });
        }

        const runExample = async () => {
            var context = new AudioContext();
            context.resume();

            document.getElementById("start-button").disabled = true;
            document.getElementById("start-button").remove();

            URLFromFiles(['string-processor.js', 'ringbuf/index.js']).then((e) => {
                context.audioWorklet.addModule(e).then(() => {
                    const audioNodes = [];
                    window["audioNodes"] = audioNodes;
                    const stringVisualizations = [];
                    window["stringVisualizations"] = stringVisualizations;
                    
                    const nodeInfo = createAudioNodeDescriptions();

                    nodeInfo.forEach((nodeInfo, j) => {
                        const f0s = [];

                        nodeInfo.strings.forEach((stringInfo, k) => {
                            f0s.push(stringInfo.f0);
                            const stringIndex = (j * window.ratio) + k;
                            createStringElement(stringInfo, stringIndex);
                        });

                        const node = new AudioWorkletNode(
                            context,
                            'string-processor',
                            {
                                processorOptions: {
                                    f0s,
                                    visualize: window.visualizeStringState
                                }
                            }
                        );

                        node.connect(context.destination);

                        if (window.communicationChannel === "port") {
                            node.port.onmessage = handleStringMessage.bind(this, j);
                        }
                        else if (window.communicationChannel === "sab") {
                            {
                                let sharedBuffer = RingBuffer.getStorageForCapacity(32 * 100, Uint8Array);
                                let ringBuffer = new RingBuffer(sharedBuffer, Uint8Array);
                                let paramReader = new ParameterReader(ringBuffer);
                                node.port.postMessage({
                                    type: "shared-buffer",
                                    buffer: sharedBuffer,
                                });

                                node.paramReader = paramReader;
                            }

                            {
                                let sharedBuffer = RingBuffer.getStorageForCapacity(31, Uint8Array);
                                let ringBuffer = new RingBuffer(sharedBuffer, Uint8Array);
                                let paramWriter = new ParameterWriter(ringBuffer);
                                node.port.postMessage({
                                    type: "shared-buffer-plucks",
                                    buffer: sharedBuffer,
                                })

                                node.paramWriter = paramWriter;
                            }
                        }

                        audioNodes.push(node);
                    });
                    

                    document.getElementById("strum-button").disabled = false;
                    document.getElementById("strum-button").style.display = "block";
                    document.getElementById("pluck-button").disabled = false;
                    document.getElementById("pluck-button").style.display = "block";
                    document.getElementById("swipe-button").disabled = false;
                    document.getElementById("swipe-button").style.display = "block";

                    if (window.visualizeStringState) {
                        requestAnimationFrame(animationFrame);
                    }
                });
            });
        };

        const onMidiInput = (e) => {
            if (window.strings) {
                pluck();
            }
        }

        const onMidiInputSelectionChanged = (e) => {
            if (window.currentMidiInput) {
                WebMidi.getInputByName(window.currentMidiInput).removeListener('noteon', 'all', onMidiInput);
            }
            window.currentMidiInput = e.target.value;
            WebMidi.getInputByName(window.currentMidiInput).addListener('noteon', 'all', onMidiInput);
        };

        const updateMidiInputOptions = () => {
            const select = document.querySelector('#webmidi-control select');
            select.innerHTML = WebMidi.inputs.map(input => `<option value="${input.name}">${input.name}</option>`).join();
            select.onchange = onMidiInputSelectionChanged;
            onMidiInputSelectionChanged({ target: select });
        };

        const initializeMidi = (err) => {
            if (err) return;
            const webMidiSection = document.querySelector('#webmidi-control');
            webMidiSection.querySelector('p').innerText = "Select from one of the available MIDI input devices.";
            webMidiSection.innerHTML += `
                <div>
                    <label style="font-size: 0.8em;" for="webmidi-input">Device</label>
                    <select id="webmidi-input"></select>
                    <button type="button" onclick="updateMidiInputOptions()">refresh</button>
                </div>
`;
            updateMidiInputOptions()
        };
        WebMidi.enable(initializeMidi);

        const createStringElement = (info, i) => {
            const stringVis = document.createElement("div");
            const bigness = (1 - (info.f0 / 1000));
            const widthness = (1 - (info.f0 / 3000));
            stringVis.style.width = `${Math.max(Math.pow(widthness, 3) * 100, 1)}%`;
            stringVis.style.height = `${Math.max(bigness * 4, 1.5)}px`;
            stringVis.style.backgroundColor = "hotpink";
            stringVis.style.margin = "6px";
            stringVis.style.borderRadius = "10px";
            stringVis.style.opacity = 0.2;
            stringVis.id = `string${i}`;

            const stringHitarea = document.createElement("div");
            stringHitarea.style.width = `${Math.max(Math.pow(widthness, 3) * 100, 1)}%`;
            stringHitarea.style.height = `${Math.max(bigness * 4, 1.5)}px`;
            stringHitarea.style.backgroundColor = "none";
            stringHitarea.style.margin = "6px";
            stringHitarea.style.borderRadius = "10px";
            stringHitarea.style.cursor = "pointer";
            stringHitarea.id = `string-hitarea${i}`;

            stringHitarea.addEventListener("mouseover", () => {
                pluckString(i);
            })
            stringHitarea.addEventListener("click", () => {
                pluckString(i);
            })

            window.stringVisualizations[i] = stringVis;
            document.getElementById("vis").appendChild(stringVis);
            document.getElementById("vis-hitareas").appendChild(stringHitarea);
        }

        const animationFrame = () => {
            if (window.communicationChannel === "sab") {
                // variable to hold result of dequeue_change
                let o = { index: 0, value: 0 };
                audioNodes.forEach((node, nodeIndex) => {
                    while (node.paramReader.dequeue_change(o)) {
                        const isAmplitude = o.index % 2 === 0;
                        const stringIndex = Math.floor(o.index / 2);
                        const globalStringIndex = window.ratio * nodeIndex + stringIndex;

                        if (isAmplitude) {
                            stringAmplitudes[globalStringIndex] = o.value;
                        } else {
                            stringVibrations[globalStringIndex] = o.value;
                        }
                    }
                })
            }

            for (let i = 0; i < window.numStrings; i++) {
                const amplitude = window.stringAmplitudes[i];
                const vibration = window.stringVibrations[i];
                if (amplitude > 0.001) {
                    const element = window.stringVisualizations[i];
                    element.style.opacity = Math.max(0.20, amplitude * 10);
                    element.style.transform = `translateY(${vibration * 25 * (amplitude * 2)}px)`;
                }
            }

            requestAnimationFrame(animationFrame);
        }

        const handleStringMessage = (nodeIndex, message) => {
            const stringIndex = (nodeIndex * window.ratio) + message.data.stringIndex;
            window.stringAmplitudes[stringIndex] = message.data.amplitude;
            window.stringVibrations[stringIndex] = message.data.vibration;
        }
        
        const pluckString = (i) => {
            const nodeIndex = stringIndexToNodeIndex(i);
            if (window.communicationChannel === "port") {
                audioNodes[nodeIndex].port.postMessage({type: "play", stringIndex: i % window.ratio});
            } else if (window.communicationChannel === "sab") {
                audioNodes[nodeIndex].paramWriter.enqueue_change(i % window.ratio, true);
            }
        }

        const strum = () => {
            for (let i = 0; i < window.numStrings; i++) {
                setTimeout(() => { pluckString(i); }, i * 50)
            }
        }

        const pluck = () => {
            pluckString(Math.floor(Math.random() * 10));
        }

        const swipe = () => {
            const stringsToSwipe = 5;
            const startString = Math.floor(Math.random() * (window.numStrings - stringsToSwipe));
            for (let i = 0; i < stringsToSwipe; i++) {
                setTimeout(() => { pluckString(i + startString); }, i * 50)
            }
        }

        const changeStrings = (number) => {
            reloadWith(number, window.visualizeStringState, window.communicationChannel, window.ratio);
        }

        const toggleStringVisualization = () => {
            reloadWith(window.numStrings, !window.visualizeStringState, window.communicationChannel, window.ratio);
        }

        const changeChannel = (channel) => {
            reloadWith(window.numStrings, window.visualizeStringState, channel, window.ratio);
        }

        const changeRatio = (ratio) => {
            reloadWith(window.numStrings, window.visualizeStringState, window.communicationChannel, ratio);
        }

        const reloadWith = (strings, visualize, channel, ratio) => {
            const newUrl = `${window.location.origin}${window.location.pathname}?strings=${strings}&visualize=${visualize}&channel=${channel}&ratio=${ratio}`;
            window.location.href = newUrl;
        }

        const urlParams = new URLSearchParams(window.location.search);

        const numStrings = urlParams.get('strings')
            ? parseInt(urlParams.get('strings'))
            : 25;

        const visualizeStringState = urlParams.get('visualize') === "false"
            ? false
            : true;

        const communicationChannel = urlParams.get('channel') === "sab"
            ? "sab"
            : "port";

        const ratio = urlParams.get('ratio')
            ? parseInt(urlParams.get('ratio'))
            : 100;

        const stringIndexToNodeIndex = (i) => {
            return Math.floor(i / window.ratio);
        }
        
        const infoForStringIndex = (i) => {
            const stringsInEachSet = 25;
            const stringSet = Math.floor(i / stringsInEachSet);
            const mod = i % stringsInEachSet;
            const setF0 = 30 + (stringSet * 10);
            return { f0: setF0 + (setF0 * mod) };
        }
    
        const createAudioNodeDescriptions = () => {
            const nodeDescriptions = [];
            const nodeCount = Math.ceil(window.numStrings / window.ratio);
            for (let i = 0; i < nodeCount; i++) {
                nodeDescriptions.push({strings: []});
            }

            for (let i = 0; i < window.numStrings; i++) {
                const nodeIndex = stringIndexToNodeIndex(i);
                nodeDescriptions[nodeIndex].strings.push(infoForStringIndex(i));
            }

            return nodeDescriptions;
        }

        window.numStrings = numStrings;
        window.stringAmplitudes = new Array(numStrings).fill(0);
        window.stringVibrations = new Array(numStrings).fill(0);
        window.visualizeStringState = visualizeStringState;
        window.communicationChannel = communicationChannel;
        window.ratio = ratio;
        document.getElementById(`${numStrings}-button`).style.outline = "solid 2px hotpink";
        document.getElementById("vis-checkbox").checked = visualizeStringState;
        switch (communicationChannel) {
            case "sab": document.getElementById("choice-sab").checked = true; break;
            case "port": document.getElementById("choice-port").checked = true; break;
        }
        switch (ratio) {
            case 1: document.getElementById("choice-1").checked = true; break;
            case 100: document.getElementById("choice-100").checked = true; break;
        }
    </script>
</body>

</html>